\section{\software}

\subsection{Node Overlap Removal Algorithm}

% \begin{noindent}
\begin{algorithm}[hbt!]
    \caption{An overview of all steps in \software.}\label{alg:overview}
    \textbf{Variables:} \\
    $NodeList \gets$ a list of nodes representing CCGs \\
    $Node_{size}\gets$ the current size of all nodes \\
    $Node_{inc} \gets$ the increment node size of each iteration \\
    $Node_{max} \gets$ the maximum size of a node \\

    \begin{algorithmic}[1]
        \While{$ Node_{size} < Node_{max} $}
            \State RemoveOverlap ($ NodeList $)
            \State $Node_{size} \gets Node_{size} + Node_{inc}$
        \EndWhile
    \end{algorithmic}
\end{algorithm}

\begin{algorithm}[hbt!]
    \caption{A function to remove node overlaps.}\label{alg:remove overlap}
    \textbf{Variables:} \\
    $Node_{stale} \gets$ the maximum number of iterations before a stalemate \\
    \begin{algorithmic}[1]
        \Function{RemoveOverlap}{$ NodeList $}
        \State $ recurse \gets False$
        \State $ nodeList_{ora} \gets $ RunOverlapRemoval ($ NodeList $)
            \For{$ node^i_{ora} \in nodeList_{ora} $}
                \If {MoveNode ($ Node^i, node^i_{ora} $)}
                    \State $ cross \gets $ CheckRiverCrossing ($ Node^i, node^i_{ora} $)
                    \If{$ cross = True $}
                        \State $recurse \gets True$
                        \State $ Node^i.stale \gets Node^i.stale + 1 $
                        \If{$ Node^i.stale < Node_{stale} $}
                            \State MoveNode ($ Node^i $)
                        \Else
                            \State DeriveCorridor ($ Node^i, node^i_{ora} $)
                        \EndIf
                    \EndIf
                \EndIf
            \EndFor
            \If{$ recurse = True $}
                \State RemoveOverlap ($ NodeList $)
            \EndIf
        \EndFunction
    \end{algorithmic}
\end{algorithm}


\begin{algorithm}[hbt!]
    \caption{A function to update a node's position.}\label{alg:move position}
    \begin{algorithmic}[1]
        \Function{MoveNode}{$ Node, Node_{ora} $}
        \If{$ Node.x = Node_{ora}.x $ and $ Node.y = Node_{ora}.y $}
            \State \Return{$ False $}
        \EndIf
        
        \State init. $ x,y $

        \If{$ Node_{ora}$ is $ undefined $}
            \State $previous \gets Node.history.pop() $
            \State $ x \gets previous.x,~y \gets previous.y $
        \Else
            \State $ x \gets Node_{ora}.x,~y \gets Node_{ora}.y $
            \State $ Node.history.push(x, y) $
        \EndIf

        \State $ Node.x \gets x $
        \State $ Node.y \gets y $
        \State \Return{$ True $}
        \EndFunction
    \end{algorithmic}
\end{algorithm}

\begin{algorithm}[hbt!]
    \caption{A function to check if a node crosses a river.}\label{alg:check river crossing}
    \textbf{Variables:} \\
    $RiverEdges \gets$ a list of river edges \\

    \begin{algorithmic}[1]
        \Function{CheckRiverCrossing}{$ Node, Node_{ora} $}
            \For{$ edge \in RiverEdges $}
                \State $ node_b \gets $ GenerateBoundary ($ Node, Node_{ora} $)
                \State $ edge_b \gets $ GenerateBoundary ($ edge $)
                \State $ collide \gets $ DetectBoundaryCollision ($ node_b, edge_b $)
                \If{$ collide = True $}
                    \State $ node_l \gets $ GenerateLine ($ Node, Node_{ora} $)
                    \State $ edge_l \gets $ GenerateLine ($ edge $)
                    \State $ intersect \gets $ DetectLineIntersection ($ node_l, edge_l $)
                    \If{$ intersect = True $}
                        \State \Return{$ True $}
                    \EndIf
                \EndIf
            \EndFor
            \State \Return{$ False $}
        \EndFunction
    \end{algorithmic}
\end{algorithm}


\begin{algorithm}[hbt!]
    \caption{A function to derive a corridor to include and move neighboring nodes. On a SVG canvas, the point of origin (0,0) is at the top left corner, with the x-axis extending to the right and the y-axis extending to the bottom, there is no negative axes.}\label{alg:derive corridor}
    \textbf{Variables:} \\
    $C_l \gets$ the length of a corridor \\
    $C_{w} \gets$ the width of a corridor \\
    $Node_{size}\gets$ the current size of all nodes \\
    \begin{algorithmic}[1]
        \Function{DeriveCorridor}{$ Node, Node_{ora} $}
        \State MoveNode ($ Node $)

        \State $ \Delta x \gets Node.x - Node_{ora}.x,~ \Delta y \gets Node.y - Node_{ora}.y $

        \State $ \vec{diff} \gets
            \begin{pmatrix}
                \Delta x \\
                \Delta y
            \end{pmatrix},~ \vec{Node} \gets
            \begin{pmatrix}
                    Node.x \\
                    Node.y
            \end{pmatrix} $

        \State $ \vec{p} \gets
            \vec{Node} + \sqrt{
                C_{l}^2 \cdot (\Delta x + \Delta y))
            } \cdot \vec{diff} $
        
        \State $ shift \gets
                \sqrt{ 
                    \frac{C_{w}^2}{2}
                },~ \vec{shift_a} \gets \begin{pmatrix}
                    shift \\
                    - shift
                \end{pmatrix},~ \vec{shift_b} \gets \begin{pmatrix}
                    - shift \\
                    +shift
                \end{pmatrix} $

        \State $ corridor \gets
            \begin{bmatrix}
                \vec{Node} + \vec{shift_a} &
                \vec{p}+ \vec{shift_a} \\

                \vec{Node} + \vec{shift_b} &
                \vec{p}+ \vec{shift_b} \\
            \end{bmatrix} $

        \For{$ node^i $ inside $ corridor $}
            \State MoveNode ($ node^i,  $)
        \EndFor

        \EndFunction
    \end{algorithmic}
\end{algorithm}
%\end{noindent}